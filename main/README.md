
1. 画像の読み込み
 - BMPファイルの読み込み
 - 読み込んだファイルをRGB形式の二次元配列に格納
 - 1pxずつrgb->hsv形式に変換
2. バウンディングボックスの作成
 - 配列の行を一つ一つ読み取る
 - 果物の頂点(最初の端っこの点)を見つける
 - その頂点(果物の端の色)で、なんの果物かを判別する
 以下の3つの関数で各ピクセルの色を判定：
   - `isAppleColor`: りんごの色範囲内か 84px,
   - `isOrangeColor`: みかん/かきの色範囲内か 77px,/80px
ミカンと柿はほぼ同じ色のため同じとして扱う。(使用する範囲は柿)
パディング15px

それぞれの判定には、コンストラクタで設定された閾値を使用：
```cpp
thresholds.apple = {0, 10, 65, 237, 30, 211};  // H, S, V の最小・最大値
thresholds.orange = {11, 19, 192, 255, 162, 255};
thresholds.stem = {14, 41, 78, 222, 76, 161};
```
 - その判別された果物の中心点を求める(あらかじめ果物別に指定された半径を使用)
 - その果物の中心点から左右上下(あらかじめ設定した半径分)に円をプロットする
 - 円の範囲の中の配列にindexで印をつける(0,1,2,...)
 - 次の行の配列を一つ一つ読み取る
 - 果物の頂点(最初の端っこの点)を見つける。(まだindexで印がついていない範囲で)
 - これの繰り返し

これで果物の大まかなバウンディングボックスを描く(円形)

==============

# 1. 画像の読み込みと前処理
- BMPファイルを読み込む
- RGB形式の二次元配列にデータを格納
- 各ピクセル(1px)をRGBからHSV形式に変換

# 2. 果物の検出とバウンディングボックスの作成
## 2.1. 色範囲の事前定義
```cpp
// HSVの閾値を設定
thresholds.apple = {0, 10, 65, 237, 30, 211};    // H, S, V の最小・最大値
thresholds.orange = {11, 19, 192, 255, 162, 255};
thresholds.stem = {14, 41, 78, 222, 76, 161};
```

## 2.2. 検出処理
- 画像を上から1行ずつスキャン
- 果物の色判定関数を使用
  - `isAppleColor`: りんご判定（84px）
  - `isOrangeColor`: みかん/かき判定（77px/80px）
    - みかんと柿は色が近いため同じ判定基準を使用（柿の色範囲を採用）
- パディング: 15px (実際の値より15px大きめに円を描く)

## 2.3. 果物の特定と重複防止
1. 果物の頂点（最上部の点）を検出
2. 頂点の色から果物の種類を判別
3. 中心点を計算（果物ごとに事前定義された半径を使用し、頂点から真下に半径分だけ下の位置を中心点とする）
4. 中心点をもとに円をプロット
5. 円の範囲内の配列に果物の種類のフラグを設定（重複検出防止）
6. フラグが未設定の領域のみを次の検出対象とする

## 2.4. 最終出力
- 検出された果物の位置に応じて色付きの四角形（バウンディングボックス）を描画
  - りんご: 緑色の枠
  - みかん: 赤色の枠
  - かき: 青色の枠

==============

改善点  
 - 連結成分分析
 - 1pxずつ → スキャンライン